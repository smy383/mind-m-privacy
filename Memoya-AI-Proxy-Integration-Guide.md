# üìö Memoya AI ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ Ïó∞Îèô Í∞ÄÏù¥Îìú

Ïô∏Î∂Ä Í∞úÎ∞úÏûêÎ•º ÏúÑÌïú ÏôÑÏ†ÑÌïú Ïó∞Îèô Îß§Îâ¥Ïñº

---

## üéØ Í∞úÏöî

**Memoya AI ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ**Îäî Google Gemini APIÎ•º ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî ÌîÑÎ°ùÏãú ÏÑúÎπÑÏä§ÏûÖÎãàÎã§. API ÌÇ§Î•º ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÎÖ∏Ï∂úÌïòÏßÄ ÏïäÍ≥†ÎèÑ AI Í∏∞Îä•ÏùÑ Ïï±Ïóê ÌÜµÌï©Ìï† Ïàò ÏûàÏäµÎãàÎã§.

### ‚úÖ ÏßÄÏõê Í∏∞Îä•
- Google Gemini AI Î™®Îì† Î™®Îç∏ ÏßÄÏõê
- Function Calling (ÎèÑÍµ¨ ÏÇ¨Ïö©) ÏôÑÎ≤Ω ÏßÄÏõê
- Îã§Íµ≠Ïñ¥ ÎåÄÌôî ÏßÄÏõê
- Ïã§ÏãúÍ∞Ñ ÎåÄÌôî Ï≤òÎ¶¨
- ÏïàÏ†ÑÌïú API ÌÇ§ Í¥ÄÎ¶¨

### üåê ÏÑúÎ≤Ñ Ï†ïÎ≥¥
- **Base URL**: `https://memoya-proxy-production.up.railway.app`
- **Status**: 24/7 Ïö¥ÏòÅ Ï§ë
- **Rate Limit**: Gemini API Ïú†Î£å ÌîåÎûú Í∏∞Ï§Ä (Î∂ÑÎãπ 1,000 requests)
- **ÏßÄÏõê Î™®Îç∏**: Î™®Îì† Gemini Î™®Îç∏ (Ïï±ÏóêÏÑú ÏÑ†ÌÉù)

---

## üöÄ Îπ†Î•∏ ÏãúÏûë

### 1. Í∏∞Î≥∏ AI Ï±ÑÌåÖ Ïó∞Îèô

```javascript
// Í∏∞Î≥∏ AI Ï±ÑÌåÖ ÏöîÏ≤≠
const sendMessage = async (userMessage) => {
  const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      contents: [
        {
          parts: [{ text: userMessage }],
          role: 'user'
        }
      ]
    })
  });
  
  const data = await response.json();
  return data.candidates[0].content.parts[0].text;
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const aiResponse = await sendMessage("ÏïàÎÖïÌïòÏÑ∏Ïöî! Ïò§Îäò ÎÇ†Ïî®Í∞Ä Ïñ¥ÎïåÏöî?");
console.log(aiResponse); // AIÏùò ÏùëÎãµ
```

### 2. Î™®Îç∏ ÏÑ†ÌÉùÌïòÍ∏∞

```javascript
// ÌäπÏ†ï Î™®Îç∏ ÏÇ¨Ïö© (URLÏóê Î™®Îç∏ ÏßÄÏ†ï)
const sendMessageWithModel = async (userMessage, model = 'gemini-1.5-flash-8b') => {
  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Î™®Îç∏ Í≤∞Ï†ï
  const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
  
  const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      contents: [
        {
          parts: [{ text: userMessage }],
          role: 'user'
        }
      ]
    })
  });
  
  return response.json();
};
```

**ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îç∏:**
- `gemini-1.5-flash-8b` (Í∏∞Î≥∏, Îπ†Î¶Ñ, Ï†ÄÎπÑÏö©)
- `gemini-1.5-pro` (Í≥†ÏÑ±Îä•, Î≥µÏû°Ìïú ÏûëÏóÖ)
- `gemini-2.0-flash-exp` (Ïã§ÌóòÏ†Å, ÏµúÏã† Í∏∞Îä•)

---

## üí¨ Í≥†Í∏â Í∏∞Îä•

### 3. ÎåÄÌôî Ïù¥Î†• Ïú†ÏßÄ

```javascript
class AIChat {
  constructor() {
    this.chatHistory = [];
  }
  
  async sendMessage(userMessage, systemPrompt = '') {
    // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ Ï∂îÍ∞Ä (ÏÑ†ÌÉùÏÇ¨Ìï≠)
    const messages = [];
    if (systemPrompt) {
      messages.push({
        parts: [{ text: systemPrompt }],
        role: 'user'
      });
    }
    
    // ÎåÄÌôî Ïù¥Î†• Ï∂îÍ∞Ä
    messages.push(...this.chatHistory);
    
    // ÏÉà ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    messages.push({
      parts: [{ text: userMessage }],
      role: 'user'
    });
    
    const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: messages
      })
    });
    
    const data = await response.json();
    const aiResponse = data.candidates[0].content.parts[0].text;
    
    // ÎåÄÌôî Ïù¥Î†• ÏóÖÎç∞Ïù¥Ìä∏
    this.chatHistory.push(
      { parts: [{ text: userMessage }], role: 'user' },
      { parts: [{ text: aiResponse }], role: 'model' }
    );
    
    return aiResponse;
  }
  
  clearHistory() {
    this.chatHistory = [];
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const chat = new AIChat();
await chat.sendMessage("ÏïàÎÖïÌïòÏÑ∏Ïöî!", "ÎãπÏã†ÏùÄ ÎèÑÏõÄÏù¥ ÎêòÎäî AI Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§.");
await chat.sendMessage("Ï†ú Ïù¥Î¶ÑÏùÄ ÌôçÍ∏∏ÎèôÏûÖÎãàÎã§.");
await chat.sendMessage("Ï†ú Ïù¥Î¶ÑÏù¥ Î≠êÏòÄÏ£†?"); // "ÌôçÍ∏∏ÎèôÏûÖÎãàÎã§" ÎùºÍ≥† Í∏∞ÏñµÌï®
```

### 4. Function Calling (ÎèÑÍµ¨ ÏÇ¨Ïö©)

```javascript
// AIÍ∞Ä ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî ÎèÑÍµ¨ Ï†ïÏùò
const tools = [
  {
    functionDeclarations: [
      {
        name: "get_weather",
        description: "ÌòÑÏû¨ ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§",
        parameters: {
          type: "object",
          properties: {
            location: {
              type: "string",
              description: "ÎÇ†Ïî®Î•º ÌôïÏù∏Ìï† ÎèÑÏãúÎ™Ö"
            }
          },
          required: ["location"]
        }
      },
      {
        name: "calculate",
        description: "ÏàòÌïô Í≥ÑÏÇ∞ÏùÑ ÏàòÌñâÌï©ÎãàÎã§",
        parameters: {
          type: "object",
          properties: {
            expression: {
              type: "string",
              description: "Í≥ÑÏÇ∞Ìï† ÏàòÏãù (Ïòà: 2+3*4)"
            }
          },
          required: ["expression"]
        }
      }
    ]
  }
];

const sendMessageWithTools = async (userMessage) => {
  let messages = [
    {
      parts: [{ text: userMessage }],
      role: 'user'
    }
  ];
  
  while (true) {
    const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: messages,
        tools: tools,
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY" // AIÍ∞Ä ÌïÑÏöîÏãú ÎèÑÍµ¨ ÏÇ¨Ïö©
          }
        }
      })
    });
    
    const data = await response.json();
    const candidate = data.candidates[0];
    const parts = candidate.content.parts;
    
    // Function Call ÌôïÏù∏
    const functionCall = parts.find(part => part.functionCall);
    
    if (functionCall) {
      // ÎèÑÍµ¨ Ïã§Ìñâ
      const result = await executeFunction(functionCall.functionCall);
      
      // Í≤∞Í≥ºÎ•º AIÏóêÍ≤å Ï†ÑÎã¨
      messages.push(
        { parts: [functionCall], role: 'model' },
        { 
          parts: [{
            functionResponse: {
              name: functionCall.functionCall.name,
              response: result
            }
          }], 
          role: 'function' 
        }
      );
    } else {
      // ÏµúÏ¢Ö ÏùëÎãµ
      return parts[0].text;
    }
  }
};

// ÎèÑÍµ¨ Ïã§Ìñâ Ìï®Ïàò
const executeFunction = async (functionCall) => {
  switch (functionCall.name) {
    case 'get_weather':
      return {
        location: functionCall.args.location,
        temperature: '23¬∞C',
        condition: 'ÎßëÏùå'
      };
      
    case 'calculate':
      try {
        const result = eval(functionCall.args.expression);
        return { result: result };
      } catch (error) {
        return { error: 'Í≥ÑÏÇ∞ Ïò§Î•ò' };
      }
      
    default:
      return { error: 'Ïïå Ïàò ÏóÜÎäî Ìï®Ïàò' };
  }
};

// ÏÇ¨Ïö© ÏòàÏ†ú
const response = await sendMessageWithTools("ÏÑúÏö∏ ÎÇ†Ïî® Ïñ¥Îïå? Í∑∏Î¶¨Í≥† 2+3*4 Í≥ÑÏÇ∞Ìï¥Ï§ò");
// AIÍ∞Ä ÏûêÎèôÏúºÎ°ú get_weatherÏôÄ calculate Ìï®ÏàòÎ•º Ìò∏Ï∂úÌïòÏó¨ ÎãµÎ≥Ä
```

---

## üõ†Ô∏è ÌîåÎû´ÌèºÎ≥Ñ Íµ¨ÌòÑ

### React Native

```typescript
import { useState, useCallback } from 'react';

interface AIMessage {
  id: string;
  text: string;
  isUser: boolean;
  timestamp: Date;
}

export const useAI = () => {
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = useCallback(async (userMessage: string) => {
    setIsLoading(true);
    
    // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    const userMsg: AIMessage = {
      id: Date.now().toString(),
      text: userMessage,
      isUser: true,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMsg]);

    try {
      const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [{ text: userMessage }],
              role: 'user'
            }
          ]
        })
      });

      const data = await response.json();
      const aiResponse = data.candidates[0].content.parts[0].text;

      // AI ÏùëÎãµ Ï∂îÍ∞Ä
      const aiMsg: AIMessage = {
        id: (Date.now() + 1).toString(),
        text: aiResponse,
        isUser: false,
        timestamp: new Date()
      };
      setMessages(prev => [...prev, aiMsg]);

    } catch (error) {
      console.error('AI Ïò§Î•ò:', error);
      // Ïò§Î•ò Ï≤òÎ¶¨
    } finally {
      setIsLoading(false);
    }
  }, []);

  return {
    messages,
    sendMessage,
    isLoading
  };
};
```

### Flutter

```dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class AIService {
  static const String _baseUrl = 'https://memoya-proxy-production.up.railway.app';
  
  static Future<String> sendMessage(String userMessage) async {
    final response = await http.post(
      Uri.parse('$_baseUrl/api/gemini'),
      headers: {
        'Content-Type': 'application/json',
      },
      body: jsonEncode({
        'contents': [
          {
            'parts': [{'text': userMessage}],
            'role': 'user'
          }
        ]
      }),
    );
    
    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['candidates'][0]['content']['parts'][0]['text'];
    } else {
      throw Exception('AI ÏÑúÎπÑÏä§ Ïò§Î•ò');
    }
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
class ChatScreen extends StatefulWidget {
  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final TextEditingController _controller = TextEditingController();
  List<String> messages = [];
  bool isLoading = false;

  Future<void> _sendMessage() async {
    if (_controller.text.isEmpty) return;
    
    final userMessage = _controller.text;
    _controller.clear();
    
    setState(() {
      messages.add('ÏÇ¨Ïö©Ïûê: $userMessage');
      isLoading = true;
    });
    
    try {
      final aiResponse = await AIService.sendMessage(userMessage);
      setState(() {
        messages.add('AI: $aiResponse');
      });
    } catch (error) {
      setState(() {
        messages.add('Ïò§Î•ò: $error');
      });
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }
}
```

### Web (JavaScript/TypeScript)

```html
<!DOCTYPE html>
<html>
<head>
    <title>AI Chat</title>
</head>
<body>
    <div id="chat-container"></div>
    <input type="text" id="message-input" placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî">
    <button onclick="sendMessage()">Ï†ÑÏÜ°</button>

    <script>
        let chatHistory = [];
        
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const userMessage = input.value.trim();
            if (!userMessage) return;
            
            // UI ÏóÖÎç∞Ïù¥Ìä∏
            addMessageToChat('ÏÇ¨Ïö©Ïûê', userMessage);
            input.value = '';
            
            try {
                const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [
                            {
                                parts: [{ text: userMessage }],
                                role: 'user'
                            }
                        ]
                    })
                });
                
                const data = await response.json();
                const aiResponse = data.candidates[0].content.parts[0].text;
                
                addMessageToChat('AI', aiResponse);
                
            } catch (error) {
                addMessageToChat('ÏãúÏä§ÌÖú', 'Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
            }
        }
        
        function addMessageToChat(sender, message) {
            const container = document.getElementById('chat-container');
            const messageDiv = document.createElement('div');
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        // Enter ÌÇ§ Ï≤òÎ¶¨
        document.getElementById('message-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
    </script>
</body>
</html>
```

---

## üîß ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è ÎîîÎ≤ÑÍπÖ

### ÏùºÎ∞òÏ†ÅÏù∏ ÏóêÎü¨ÏôÄ Ìï¥Í≤∞Ï±Ö

```javascript
const sendMessageWithErrorHandling = async (userMessage) => {
  try {
    const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [{ text: userMessage }],
            role: 'user'
          }
        ]
      })
    });
    
    // HTTP ÏóêÎü¨ Ï≤¥ÌÅ¨
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Gemini API ÏóêÎü¨ Ï≤¥ÌÅ¨
    if (data.error) {
      throw new Error(`Gemini API Error: ${data.error.message}`);
    }
    
    // ÏùëÎãµ Íµ¨Ï°∞ ÌôïÏù∏
    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      throw new Error('ÏûòÎ™ªÎêú ÏùëÎãµ ÌòïÏãù');
    }
    
    return data.candidates[0].content.parts[0].text;
    
  } catch (error) {
    console.error('AI ÏÑúÎπÑÏä§ Ïò§Î•ò:', error);
    
    // ÏóêÎü¨ Ïú†ÌòïÎ≥Ñ Ï≤òÎ¶¨
    if (error.message.includes('HTTP Error: 429')) {
      return 'ÎÑàÎ¨¥ ÎßéÏùÄ ÏöîÏ≤≠ÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.';
    } else if (error.message.includes('HTTP Error: 500')) {
      return 'ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.';
    } else if (error.message.includes('Network')) {
      return 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.';
    } else {
      return 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
    }
  }
};
```

### ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏

```javascript
// ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏
const checkServerStatus = async () => {
  try {
    const response = await fetch('https://memoya-proxy-production.up.railway.app/');
    const status = await response.json();
    
    console.log('ÏÑúÎ≤Ñ ÏÉÅÌÉú:', status);
    /*
    Ï∂úÎ†• ÏòàÏãú:
    {
      "server": "Memoya Proxy Server",
      "version": "1.0.0",
      "status": "Ï†ïÏÉÅ ÏûëÎèô Ï§ë",
      "timestamp": "2025-08-31T14:44:23.249Z"
    }
    */
    
    return status.status === 'Ï†ïÏÉÅ ÏûëÎèô Ï§ë';
    
  } catch (error) {
    console.error('ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
    return false;
  }
};

// ÏÇ¨Ïö© ÏòàÏ†ú
if (await checkServerStatus()) {
  console.log('ÏÑúÎ≤ÑÍ∞Ä Ï†ïÏÉÅ ÏûëÎèô Ï§ëÏûÖÎãàÎã§.');
} else {
  console.log('ÏÑúÎ≤ÑÏóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§.');
}
```

---

## üéõÔ∏è Í≥†Í∏â ÏÑ§Ï†ï

### Rate Limiting Í≥†Î†§ÏÇ¨Ìï≠

```javascript
// ÏöîÏ≤≠ Í∞ÑÍ≤© Ï°∞Ï†à (Rate Limiting Î∞©ÏßÄ)
class AIServiceWithRateLimit {
  constructor(minInterval = 1000) { // ÏµúÏÜå 1Ï¥à Í∞ÑÍ≤©
    this.minInterval = minInterval;
    this.lastRequestTime = 0;
  }
  
  async sendMessage(userMessage) {
    // ÏµúÏÜå Í∞ÑÍ≤© Î≥¥Ïû•
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    
    if (timeSinceLastRequest < this.minInterval) {
      await new Promise(resolve => 
        setTimeout(resolve, this.minInterval - timeSinceLastRequest)
      );
    }
    
    this.lastRequestTime = Date.now();
    
    // Ïã§Ï†ú ÏöîÏ≤≠
    return await this.makeRequest(userMessage);
  }
  
  async makeRequest(userMessage) {
    // Í∏∞Î≥∏ ÏöîÏ≤≠ Î°úÏßÅ...
  }
}
```

### Ï∫êÏã± Íµ¨ÌòÑ

```javascript
// ÏùëÎãµ Ï∫êÏã±ÏúºÎ°ú ÏÑ±Îä• Ìñ•ÏÉÅ
class AIServiceWithCache {
  constructor() {
    this.cache = new Map();
    this.maxCacheSize = 100;
  }
  
  getCacheKey(userMessage) {
    return btoa(userMessage.toLowerCase().trim()); // Base64 Ïù∏ÏΩîÎî©
  }
  
  async sendMessage(userMessage) {
    const cacheKey = this.getCacheKey(userMessage);
    
    // Ï∫êÏãúÏóêÏÑú ÌôïÏù∏
    if (this.cache.has(cacheKey)) {
      console.log('Ï∫êÏãúÏóêÏÑú ÏùëÎãµ Î∞òÌôò');
      return this.cache.get(cacheKey);
    }
    
    // API Ìò∏Ï∂ú
    const response = await this.makeAPICall(userMessage);
    
    // Ï∫êÏãú ÌÅ¨Í∏∞ Í¥ÄÎ¶¨
    if (this.cache.size >= this.maxCacheSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    // Ï∫êÏãú Ï†ÄÏû•
    this.cache.set(cacheKey, response);
    
    return response;
  }
}
```

---

## üìä Î™®ÎãàÌÑ∞ÎßÅ Î∞è Î°úÍπÖ

### ÏÇ¨Ïö©Îüâ Ï∂îÏ†Å

```javascript
// ÏÇ¨Ïö©Îüâ ÌÜµÍ≥Ñ ÏàòÏßë
class AIServiceWithAnalytics {
  constructor() {
    this.stats = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      averageResponseTime: 0,
      lastUsed: null
    };
  }
  
  async sendMessage(userMessage) {
    const startTime = Date.now();
    this.stats.totalRequests++;
    this.stats.lastUsed = new Date();
    
    try {
      const response = await this.makeAPICall(userMessage);
      this.stats.successfulRequests++;
      
      // ÏùëÎãµ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
      const responseTime = Date.now() - startTime;
      this.updateAverageResponseTime(responseTime);
      
      return response;
      
    } catch (error) {
      this.stats.failedRequests++;
      throw error;
    }
  }
  
  updateAverageResponseTime(newTime) {
    const { successfulRequests, averageResponseTime } = this.stats;
    this.stats.averageResponseTime = 
      (averageResponseTime * (successfulRequests - 1) + newTime) / successfulRequests;
  }
  
  getStats() {
    return {
      ...this.stats,
      successRate: (this.stats.successfulRequests / this.stats.totalRequests * 100).toFixed(2) + '%'
    };
  }
}

// ÏÇ¨Ïö© ÏòàÏ†ú
const aiService = new AIServiceWithAnalytics();
await aiService.sendMessage("ÏïàÎÖïÌïòÏÑ∏Ïöî!");

console.log(aiService.getStats());
/*
{
  totalRequests: 1,
  successfulRequests: 1,
  failedRequests: 0,
  averageResponseTime: 1234,
  lastUsed: 2025-08-31T15:30:00.000Z,
  successRate: "100.00%"
}
*/
```

---

## üöÄ ÏµúÏ†ÅÌôî ÌåÅ

### 1. Î©îÏãúÏßÄ ÏµúÏ†ÅÌôî
```javascript
// Í∏¥ Î©îÏãúÏßÄÎäî ÏöîÏïΩÌï¥ÏÑú Ï†ÑÏÜ°
const optimizeMessage = (message) => {
  if (message.length > 1000) {
    return message.substring(0, 997) + "...";
  }
  return message;
};
```

### 2. Î∞∞Ïπò Ï≤òÎ¶¨
```javascript
// Ïó¨Îü¨ ÏöîÏ≤≠ÏùÑ Î∞∞ÏπòÎ°ú Ï≤òÎ¶¨
const processBatch = async (messages) => {
  const batchPromises = messages.map((msg, index) => 
    new Promise(resolve => 
      setTimeout(() => sendMessage(msg).then(resolve), index * 1000)
    )
  );
  
  return Promise.all(batchPromises);
};
```

### 3. Ïä§Ìä∏Î¶¨Î∞ç ÏùëÎãµ (ÎØ∏Îûò Í∏∞Îä•)
```javascript
// Ïã§ÏãúÍ∞Ñ ÏùëÎãµ Ïä§Ìä∏Î¶¨Î∞ç (Ìñ•ÌõÑ ÏßÄÏõê ÏòàÏ†ï)
const streamMessage = async (userMessage, onChunk) => {
  // ÌòÑÏû¨Îäî ÏùºÎ∞ò ÏùëÎãµÎßå ÏßÄÏõê
  // Ìñ•ÌõÑ Server-Sent EventsÎÇò WebSocketÏúºÎ°ú Ïä§Ìä∏Î¶¨Î∞ç ÏßÄÏõê Í≥ÑÌöç
  const response = await sendMessage(userMessage);
  onChunk(response);
};
```

---

## üìù Ï∂îÍ∞Ä ÏòàÏ†ú ÏΩîÎìú

### React Hook ÌòïÌÉú ÏôÑÏ†Ñ Íµ¨ÌòÑ

```typescript
// hooks/useMemoyaAI.ts
import { useState, useCallback, useRef } from 'react';

interface AIMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
}

interface AIConfig {
  model?: string;
  systemPrompt?: string;
  maxHistory?: number;
}

export const useMemoyaAI = (config: AIConfig = {}) => {
  const [messages, setMessages] = useState<AIMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const {
    model = 'gemini-1.5-flash-8b',
    systemPrompt,
    maxHistory = 20
  } = config;

  const sendMessage = useCallback(async (content: string): Promise<string | null> => {
    if (!content.trim()) return null;

    setIsLoading(true);
    setError(null);

    // Ïù¥Ï†Ñ ÏöîÏ≤≠ Ï∑®ÏÜå
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();

    // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    const userMessage: AIMessage = {
      id: Date.now().toString(),
      content: content.trim(),
      role: 'user',
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);

    try {
      // ÎåÄÌôî Ïù¥Î†• Ï§ÄÎπÑ
      const recentMessages = messages.slice(-maxHistory);
      const contents = [];

      // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ Ï∂îÍ∞Ä
      if (systemPrompt) {
        contents.push({
          parts: [{ text: systemPrompt }],
          role: 'user'
        });
      }

      // Ïù¥Ï†Ñ ÎåÄÌôî Ï∂îÍ∞Ä
      recentMessages.forEach(msg => {
        contents.push({
          parts: [{ text: msg.content }],
          role: msg.role === 'user' ? 'user' : 'model'
        });
      });

      // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
      contents.push({
        parts: [{ text: content }],
        role: 'user'
      });

      const response = await fetch('https://memoya-proxy-production.up.railway.app/api/gemini', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ contents }),
        signal: abortControllerRef.current.signal
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      if (data.error) {
        throw new Error(data.error.message);
      }

      const assistantContent = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!assistantContent) {
        throw new Error('ÏùëÎãµ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§');
      }

      // AI ÏùëÎãµ Ï∂îÍ∞Ä
      const assistantMessage: AIMessage = {
        id: (Date.now() + 1).toString(),
        content: assistantContent,
        role: 'assistant',
        timestamp: new Date()
      };

      setMessages(prev => [...prev, assistantMessage]);
      return assistantContent;

    } catch (err: any) {
      if (err.name === 'AbortError') {
        return null;
      }

      const errorMessage = err.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§';
      setError(errorMessage);
      
      // ÏóêÎü¨ Î©îÏãúÏßÄÎ•º Ï±ÑÌåÖÏóê ÌëúÏãú
      const errorMessageObj: AIMessage = {
        id: (Date.now() + 2).toString(),
        content: `Ïò§Î•ò: ${errorMessage}`,
        role: 'assistant',
        timestamp: new Date()
      };

      setMessages(prev => [...prev, errorMessageObj]);
      return null;

    } finally {
      setIsLoading(false);
      abortControllerRef.current = null;
    }
  }, [messages, maxHistory, systemPrompt]);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  const cancelRequest = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  }, []);

  return {
    messages,
    sendMessage,
    clearMessages,
    cancelRequest,
    isLoading,
    error
  };
};
```

---

## ‚ö†Ô∏è Ï§ëÏöî ÏÇ¨Ìï≠ Î∞è Ï†úÌïúÏÇ¨Ìï≠

### Î≥¥Ïïà Í≥†Î†§ÏÇ¨Ìï≠
1. **API ÌÇ§ ÎÖ∏Ï∂ú Í∏àÏßÄ**: ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏΩîÎìúÏóê Ï†àÎåÄ API ÌÇ§Î•º ÌïòÎìúÏΩîÎî©ÌïòÏßÄ ÎßàÏÑ∏Ïöî
2. **HTTPS ÌïÑÏàò**: Î™®Îì† ÏöîÏ≤≠ÏùÄ HTTPSÎ•º ÌÜµÌï¥ÏÑúÎßå Ï†ÑÏÜ°Îê©ÎãàÎã§
3. **ÏûÖÎ†• Í≤ÄÏ¶ù**: ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÄ Ìï≠ÏÉÅ Í≤ÄÏ¶ùÌïòÍ≥† sanitizeÌïòÏÑ∏Ïöî

### ÏÇ¨Ïö© Ï†úÌïú
1. **Rate Limiting**: Î∂ÑÎãπ 1,000 requests (Gemini API Ïú†Î£å ÌîåÎûú Í∏∞Ï§Ä)
2. **Î©îÏãúÏßÄ Í∏∏Ïù¥**: Îã®Ïùº ÏöîÏ≤≠Îãπ ÏµúÎåÄ 30,000Ïûê
3. **ÎåÄÌôî Ïù¥Î†•**: Í∂åÏû• ÏµúÎåÄ 20-30 Î©îÏãúÏßÄ

### ÎπÑÏö© Ï†ïÎ≥¥
- ÌîÑÎ°ùÏãú ÏÑúÎ≤Ñ ÏÇ¨Ïö©Î£å: Î¨¥Î£å
- Gemini API ÎπÑÏö©ÏùÄ Ïã§Ï†ú ÏÇ¨Ïö©ÎüâÏóê Îî∞Îùº GoogleÏóêÏÑú Í≥ºÍ∏à
- ÌòÑÏû¨ Í∞úÎ∞úÏûê(memoya)Í∞Ä API ÎπÑÏö© Î∂ÄÎã¥

### ÏßÄÏõê Î∞è Î¨∏Ïùò
- **Ïù¥Ïäà Î¶¨Ìè¨Ìä∏**: GitHub Issues (ÎßÅÌÅ¨ Ï†úÍ≥µ Ïãú)
- **Í∏∞Ïà† ÏßÄÏõê**: Í∞úÎ∞úÏûê Ïó∞ÎùΩÏ≤ò (ÌïÑÏöîÏãú Ï†úÍ≥µ)
- **ÏóÖÎç∞Ïù¥Ìä∏**: ÏÑúÎ≤Ñ ÏóÖÎç∞Ïù¥Ìä∏ÎÇò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÄ ÏÇ¨Ï†Ñ Í≥µÏßÄ

---

## üîö ÎßàÎ¨¥Î¶¨

Ïù¥ Í∞ÄÏù¥ÎìúÎ•º ÌÜµÌï¥ Memoya AI ÌîÑÎ°ùÏãú ÏÑúÎ≤ÑÎ•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ïó∞ÎèôÌïòÏã§ Ïàò ÏûàÏäµÎãàÎã§. Ï∂îÍ∞Ä ÏßàÎ¨∏Ïù¥ÎÇò ÏßÄÏõêÏù¥ ÌïÑÏöîÌïòÏãúÎ©¥ Ïñ∏Ï†úÎì† Ïó∞ÎùΩÏ£ºÏÑ∏Ïöî!

**Happy Coding! üöÄ**